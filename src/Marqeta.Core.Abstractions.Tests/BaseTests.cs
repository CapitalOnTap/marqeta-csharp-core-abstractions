using System.Collections.Generic;
using System.Linq;
using AutoFixture;
using AutoFixture.DataAnnotations;
using Xunit.Abstractions;

namespace Marqeta.Core.Abstractions.Tests
{
    public abstract class BaseTests
    {
        protected readonly ITestOutputHelper TestOutputHelper;

        protected BaseTests(ITestOutputHelper testOutputHelper)
        {
            TestOutputHelper = testOutputHelper;
        }

        /// <summary>
        /// Get the Fixture for use within tests
        /// </summary>
        /// <returns></returns>
        protected static Fixture GetFixture()
        {
            var fixture = new Fixture();

            // We remove data annotation consideration as the custom Enums causes generation issues
            fixture.Customize(new NoDataAnnotationsCustomization());

            // Replace ThrowingRecursionBehavior with OmitOnRecursionBehavior
            // CF: https://github.com/AutoFixture/AutoFixture/wiki/Examples-of-using-behaviors
            fixture.Behaviors.OfType<ThrowingRecursionBehavior>().ToList().ForEach(b => fixture.Behaviors.Remove(b));
            fixture.Behaviors.Add(new OmitOnRecursionBehavior());

            // Custom fixtures for balances classes
            // They cannot be autogenerated with autofixture
            fixture.Customize<Cardholder_balance>(c => c.With(p => p.Balances, new Dictionary<string, Cardholder_balance>
            {
                { fixture.Create<string>(), fixture.Build<Cardholder_balance>().Without(p => p.Balances).Create() }
            }));
            fixture.Customize<Msa_aggregated_balances>(c => c.With(p => p.Balances, new Dictionary<string, Msa_aggregated_balances>
            {
                { fixture.Create<string>(), fixture.Build<Msa_aggregated_balances>().Without(p => p.Balances).Create() }
            }));
            fixture.Customize<Msa_balances>(c => c.With(p => p.Balances, new Dictionary<string, Msa_balances>
            {
                { fixture.Create<string>(), fixture.Build<Msa_balances>().Without(p => p.Balances).Create() }
            }));
            fixture.Customize<Offer_order_aggregated_balances>(c => c.With(p => p.Balances, new Dictionary<string, Offer_order_aggregated_balances>
            {
                { fixture.Create<string>(), fixture.Build<Offer_order_aggregated_balances>().Without(p => p.Balances).Create() }
            }));
            fixture.Customize<Offer_order_balances>(c => c.With(p => p.Balances, new Dictionary<string, Offer_order_balances>
            {
                { fixture.Create<string>(), fixture.Build<Offer_order_balances>().Without(p => p.Balances).Create() }
            }));
            fixture.Customize<Program_reserve_account_balance>(c => c.With(p => p.Balances, new Dictionary<string, Program_reserve_account_balance>
            {
                { fixture.Create<string>(), fixture.Build<Program_reserve_account_balance>().Without(p => p.Balances).Create() }
            }));

            // We replace instances of System.Object with Newtonsoft.Json.Linq.JObject
            // NB: This is required as AutoFixture generates classes with empty System.Object types
            //      that are deserialised as Newtonsoft.Json.Linq.JObject.
            //      DeepEquals will incorrectly throw when comparing these type types.
            var defaultJObject = fixture.Create<Newtonsoft.Json.Linq.JObject>();
            fixture.Register<object>(() => defaultJObject);

            return fixture;
        }
    }
}